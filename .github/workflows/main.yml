name: Cryptodata development continuous delivery

on:
  push:
    branches: [ "release/1.0.0-production" ]

jobs:
  deploy:
    runs-on: self-hosted

    steps:
      - name: Checkout code
        uses: actions/checkout@v2

      # Setup kubectl command (assuming microk8s is used)
      - name: Setup MicroK8s kubectl
        run: |
          sudo snap alias microk8s.kubectl kubectl

      # Handle Airflow database secrets
      - name: Manage Kubernetes Airflow database secrets
        env:
          AIRFLOW_DB_USER: ${{ secrets.PROD_AIRFLOW_DB_USER }}
          AIRFLOW_DB_PASSWD: ${{ secrets.PROD_AIRFLOW_DB_PASSWD }}
          AIRFLOW_DB_NAME: ${{ secrets.PROD_AIRFLOW_DB_NAME }}
        run: |
          SECRET_NAME=airflow-db-secret
          kubectl create secret generic $SECRET_NAME \
            --from-literal=POSTGRES_USER="${{ env.AIRFLOW_DB_USER }}" \
            --from-literal=POSTGRES_PASSWORD="${{ env.AIRFLOW_DB_PASSWD }}" \
            --from-literal=POSTGRES_DB="${{ env.AIRFLOW_DB_NAME }}" \
            --dry-run=client -o yaml | kubectl apply -f -

      # Handle Airflow service secrets
      - name: Manage Kubernetes airflow services secrets
        env:
          AIRFLOW__DATABASE__SQL_ALCHEMY_CONN: ${{ secrets.PROD_AIRFLOW__DATABASE__SQL_ALCHEMY_CONN }}
          AIRFLOW__CORE__SQL_ALCHEMY_CONN: ${{ secrets.PROD_AIRFLOW__CORE__SQL_ALCHEMY_CONN }}
          AIRFLOW__CELERY__RESULT_BACKEND: ${{ secrets.PROD_AIRFLOW__CELERY__RESULT_BACKEND }}
          AIRFLOW__CELERY__BROKER_URL: ${{ secrets.PROD_AIRFLOW__CELERY__BROKER_URL }}
          GH_TOKEN: ${{ secrets.PROD_AIRFLOW_GH_TOKEN }}
          AIRFLOW_UID: ${{ secrets.PROD_AIRFLOW_UID }}
        run: |
          SECRET_NAME=airflow-secrets
          kubectl create secret generic $SECRET_NAME \
            --from-literal=AIRFLOW__DATABASE__SQL_ALCHEMY_CONN="${{ env.AIRFLOW__DATABASE__SQL_ALCHEMY_CONN }}" \
            --from-literal=AIRFLOW__CORE__SQL_ALCHEMY_CONN="${{ env.AIRFLOW__CORE__SQL_ALCHEMY_CONN }}" \
            --from-literal=AIRFLOW__CELERY__RESULT_BACKEND="${{ env.AIRFLOW__CELERY__RESULT_BACKEND }}" \
            --from-literal=AIRFLOW__CELERY__BROKER_URL="${{ env.AIRFLOW__CELERY__BROKER_URL }}" \
            --from-literal=GH_TOKEN="${{ env.GH_TOKEN }}" \
            --from-literal=AIRFLOW_UID="${{ env.AIRFLOW_UID }}" \
            --dry-run=client -o yaml | kubectl apply -f -

      # Repeat similar blocks for client-db-secrets, grafana-secrets, redis-secrets, scraped-consumer-secrets, and wss-secrets
      # Ensure to replace --from-literal values with the respective environment variables for each secret set

      # Example for one more block: Grafana secrets
      - name: Manage Kubernetes Grafana secrets
        env:
          GRAFANA_SECURITY_ADMIN_USER: ${{ secrets.PROD_GRAFANA_SECURITY_ADMIN_USER }}
          GRAFANA_SECURITY_ADMIN_PASSWORD: ${{ secrets.PROD_GRAFANA_SECURITY_ADMIN_PASSWORD }}
        run: |
          SECRET_NAME=grafana-secrets
          kubectl create secret generic $SECRET_NAME \
            --from-literal=GF_SECURITY_ADMIN_USER="${{ env.GRAFANA_SECURITY_ADMIN_USER }}" \
            --from-literal=GF_SECURITY_ADMIN_PASSWORD="${{ env.GRAFANA_SECURITY_ADMIN_PASSWORD }}" \
            --dry-run=client -o yaml | kubectl apply -f -

      # Manage Kubernetes Redis secrets
      - name: Manage Kubernetes Redis secrets
        env:
          REDIS_PASSWORD: ${{ secrets.PROD_REDIS_PASSWORD }}
        run: |
          SECRET_NAME=redis-secrets
          kubectl create secret generic $SECRET_NAME \
            --from-literal=redis-password="${{ env.REDIS_PASSWORD }}" \
            --dry-run=client -o yaml | kubectl apply -f -
  
      # Manage Kubernetes scraped consumer secrets
      - name: Manage Kubernetes scraped consumer secrets
        env:
          CLIENT_DB_PASSWD: ${{ secrets.PROD_CLIENT_DB_PASSWD }}
          CLIENT_DB_USER: ${{ secrets.PROD_CLIENT_DB_USER }}
          CLIENT_DB_NAME: ${{ secrets.PROD_CLIENT_DB_NAME }}
        run: |
          SECRET_NAME=scraped-consumer-secrets
          kubectl create secret generic $SECRET_NAME \
            --from-literal=POSTGRES_PASSWORD="${{ env.CLIENT_DB_PASSWD }}" \
            --from-literal=POSTGRES_USER="${{ env.CLIENT_DB_USER }}" \
            --from-literal=POSTGRES_DB="${{ env.CLIENT_DB_NAME }}" \
            --dry-run=client -o yaml | kubectl apply -f -

      # Manage Kubernetes wss scraper secrets
      - name: Manage Kubernetes wss scraper secrets
        env:
          BLOCKCHAIN_API_KEY: ${{ secrets.PROD_BLOCKCHAIN_API_KEY }}
          CLIENT_DB_PASSWD: ${{ secrets.PROD_CLIENT_DB_PASSWD }}
          CLIENT_DB_USER: ${{ secrets.PROD_CLIENT_DB_USER }}
          CLIENT_DB_NAME: ${{ secrets.PROD_CLIENT_DB_NAME }}
        run: |
          SECRET_NAME=wss-secrets
          kubectl create secret generic $SECRET_NAME \
            --from-literal=BLOCKCHAIN_API_KEY="${{ env.BLOCKCHAIN_API_KEY }}" \
            --from-literal=POSTGRES_PASSWORD="${{ env.CLIENT_DB_PASSWD }}" \
            --from-literal=POSTGRES_USER="${{ env.CLIENT_DB_USER }}" \
            --from-literal=POSTGRES_DB="${{ env.CLIENT_DB_NAME }}" \
            --dry-run=client -o yaml | kubectl apply -f -